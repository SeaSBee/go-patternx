
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bloom: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/SeaSBee/go-patternx/patternx/bloom/bloom.go (43.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package bloom

import (
        "context"
        "crypto/md5"
        "crypto/sha256"
        "encoding/binary"
        "encoding/json"
        "errors"
        "fmt"
        "hash/fnv"
        "math"
        "sync"
        "sync/atomic"
        "time"

        "github.com/seasbee/go-logx"
)

// Common errors for Bloom Filter operations
var (
        ErrInvalidConfig         = errors.New("invalid bloom filter configuration")
        ErrEmptyItem             = errors.New("item cannot be empty")
        ErrItemTooLong           = errors.New("item exceeds maximum length")
        ErrCapacityExceeded      = errors.New("bloom filter capacity exceeded")
        ErrStoreUnavailable      = errors.New("store is not available")
        ErrContextCancelled      = errors.New("operation cancelled by context")
        ErrInvalidFalsePositive  = errors.New("false positive rate must be between 0 and 1")
        ErrInvalidExpectedItems  = errors.New("expected items must be greater than 0")
        ErrInvalidSize           = errors.New("bloom filter size is invalid")
        ErrInvalidHashCount      = errors.New("hash count is invalid")
        ErrStoreOperationFailed  = errors.New("store operation failed")
        ErrSerializationFailed   = errors.New("failed to serialize bloom filter state")
        ErrDeserializationFailed = errors.New("failed to deserialize bloom filter state")
        ErrFilterClosed          = errors.New("bloom filter is closed")
)

// Constants for production constraints
const (
        MaxItemLength    = 1024 * 1024   // 1MB max item length
        MaxExpectedItems = 1_000_000_000 // 1 billion max expected items
        MinExpectedItems = 1             // Minimum expected items
        MaxFalsePositive = 0.5           // 50% max false positive rate
        MinFalsePositive = 1e-6          // 0.0001% min false positive rate
        MaxHashCount     = 50            // Maximum number of hash functions
        MinHashCount     = 1             // Minimum number of hash functions
        MaxBitsetSize    = 1e10          // 10 billion max bitset size
        DefaultTTL       = 24 * time.Hour
        DefaultKeyPrefix = "bloom"
        MaxRetryAttempts = 3
        RetryDelay       = 100 * time.Millisecond
)

// BloomFilter implements a production-ready probabilistic data structure for membership testing
type BloomFilter struct {
        mu                sync.RWMutex
        storeMu           sync.Mutex // Dedicated mutex for store operations
        bitset            []bool
        size              uint64
        hashCount         int
        itemCount         uint64
        maxItems          uint64
        falsePositiveRate float64
        store             BloomStore
        keyPrefix         string
        ttl               time.Duration
        closed            int32 // Atomic flag for closed state
        metrics           *Metrics
}

// Metrics tracks Bloom filter performance and usage statistics with atomic operations
type Metrics struct {
        AddOperations           atomic.Uint64
        ContainsOperations      atomic.Uint64
        AddBatchOperations      atomic.Uint64
        ContainsBatchOperations atomic.Uint64
        FalsePositives          atomic.Uint64
        TrueNegatives           atomic.Uint64
        StoreOperations         atomic.Uint64
        StoreErrors             atomic.Uint64
        mu                      sync.RWMutex // For complex metrics that can't be atomic
        LastAddTime             time.Time
        LastContainsTime        time.Time
        AverageAddLatency       time.Duration
        AverageContainsLatency  time.Duration
}

// BloomStore defines the interface for persisting bloom filter state
type BloomStore interface {
        Set(ctx context.Context, key string, value []byte, ttl time.Duration) error
        Get(ctx context.Context, key string) ([]byte, error)
        Del(ctx context.Context, key string) error
        Exists(ctx context.Context, key string) (bool, error)
}

// Config holds Bloom filter configuration with validation
type Config struct {
        ExpectedItems     uint64        // Expected number of items
        FalsePositiveRate float64       // Desired false positive rate (0.01 = 1%)
        Store             BloomStore    // Optional store for persistence
        KeyPrefix         string        // Key prefix for store operations
        TTL               time.Duration // TTL for stored data
        EnableMetrics     bool          // Enable performance metrics
}

// BloomFilterState represents the serializable state of a Bloom filter
type BloomFilterState struct {
        ItemCount uint64    `json:"item_count"`
        Size      uint64    `json:"size"`
        HashCount int       `json:"hash_count"`
        Bitset    []bool    `json:"bitset"`
        Version   string    `json:"version"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// NewBloomFilter creates a new production-ready Bloom filter with comprehensive validation
func NewBloomFilter(config *Config) (*BloomFilter, error) <span class="cov3" title="12">{
        // Validate configuration
        if err := validateConfig(config); err != nil </span><span class="cov1" title="3">{
                return nil, fmt.Errorf("%w: %v", ErrInvalidConfig, err)
        }</span>

        // Apply defaults
        <span class="cov2" title="9">applyDefaults(config)

        // Calculate optimal size and hash count with validation
        size, hashCount, err := calculateOptimalParameters(config.ExpectedItems, config.FalsePositiveRate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to calculate optimal parameters: %w", err)
        }</span>

        // Create Bloom filter
        <span class="cov2" title="9">bf := &amp;BloomFilter{
                bitset:            make([]bool, size),
                size:              size,
                hashCount:         hashCount,
                maxItems:          config.ExpectedItems,
                falsePositiveRate: config.FalsePositiveRate,
                store:             config.Store,
                keyPrefix:         config.KeyPrefix,
                ttl:               config.TTL,
                metrics:           &amp;Metrics{},
        }

        // Load existing state if store is provided
        if config.Store != nil </span><span class="cov0" title="0">{
                if err := bf.loadFromStoreWithRetry(context.Background()); err != nil </span><span class="cov0" title="0">{
                        logx.Warn("Failed to load bloom filter from store, starting fresh",
                                logx.ErrorField(err),
                                logx.String("key_prefix", config.KeyPrefix))
                }</span>
        }

        <span class="cov2" title="9">logx.Info("Bloom filter created successfully",
                logx.String("size", fmt.Sprintf("%d", size)),
                logx.Int("hash_count", hashCount),
                logx.String("expected_items", fmt.Sprintf("%d", config.ExpectedItems)),
                logx.Float64("false_positive_rate", config.FalsePositiveRate),
                logx.String("key_prefix", config.KeyPrefix))

        return bf, nil</span>
}

// Add adds an item to the Bloom filter with comprehensive validation and improved context handling
func (bf *BloomFilter) Add(ctx context.Context, item string) error <span class="cov5" title="121">{
        // Check if filter is closed
        if atomic.LoadInt32(&amp;bf.closed) == 1 </span><span class="cov0" title="0">{
                return ErrFilterClosed
        }</span>

        // Validate input
        <span class="cov5" title="121">if err := validateItem(item); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid item: %w", err)
        }</span>

        // Check context cancellation before starting operation
        <span class="cov5" title="120">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %v", ErrContextCancelled, err)
        }</span>

        <span class="cov5" title="120">start := time.Now()
        defer func() </span><span class="cov5" title="120">{
                bf.updateAddMetrics(time.Since(start))
        }</span>()

        // Use a timeout context to prevent indefinite blocking
        <span class="cov5" title="120">opCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()

        bf.mu.Lock()
        defer bf.mu.Unlock()

        // Check context cancellation after acquiring lock with timeout context
        if err := opCtx.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %v", ErrContextCancelled, err)
        }</span>

        // Check capacity
        <span class="cov5" title="120">if bf.itemCount &gt;= bf.maxItems </span><span class="cov0" title="0">{
                logx.Warn("Bloom filter at capacity, item not added",
                        logx.String("item_count", fmt.Sprintf("%d", bf.itemCount)),
                        logx.String("max_items", fmt.Sprintf("%d", bf.maxItems)),
                        logx.String("item", truncateString(item, 100)))
                return fmt.Errorf("%w: current=%d, max=%d", ErrCapacityExceeded, bf.itemCount, bf.maxItems)
        }</span>

        // Get hash positions
        <span class="cov5" title="120">positions := bf.getHashPositions(item)

        // Set bits
        for _, pos := range positions </span><span class="cov7" title="840">{
                bf.bitset[pos] = true
        }</span>

        <span class="cov5" title="120">bf.itemCount++
        bf.metrics.AddOperations.Add(1)

        // Persist to store if available with dedicated store mutex
        if bf.store != nil </span><span class="cov0" title="0">{
                if err := bf.saveToStoreWithRetry(opCtx); err != nil </span><span class="cov0" title="0">{
                        logx.Error("Failed to persist bloom filter state",
                                logx.ErrorField(err),
                                logx.String("item", truncateString(item, 100)))
                        bf.metrics.StoreErrors.Add(1)
                        // Don't fail the operation if persistence fails
                }</span>
        }

        <span class="cov5" title="120">return nil</span>
}

// Contains checks if an item might be in the Bloom filter with validation and improved context handling
func (bf *BloomFilter) Contains(ctx context.Context, item string) (bool, error) <span class="cov3" title="26">{
        // Check if filter is closed
        if atomic.LoadInt32(&amp;bf.closed) == 1 </span><span class="cov0" title="0">{
                return false, ErrFilterClosed
        }</span>

        // Validate input
        <span class="cov3" title="26">if err := validateItem(item); err != nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("invalid item: %w", err)
        }</span>

        // Check context cancellation before starting operation
        <span class="cov3" title="25">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("%w: %v", ErrContextCancelled, err)
        }</span>

        <span class="cov3" title="25">start := time.Now()
        defer func() </span><span class="cov3" title="25">{
                bf.updateContainsMetrics(time.Since(start))
        }</span>()

        // Use a timeout context to prevent indefinite blocking
        <span class="cov3" title="25">opCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()

        bf.mu.RLock()
        defer bf.mu.RUnlock()

        // Check context cancellation after acquiring lock with timeout context
        if err := opCtx.Err(); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("%w: %v", ErrContextCancelled, err)
        }</span>

        // Get hash positions
        <span class="cov3" title="25">positions := bf.getHashPositions(item)

        // Check if all bits are set
        for _, pos := range positions </span><span class="cov5" title="139">{
                if !bf.bitset[pos] </span><span class="cov2" title="6">{
                        bf.metrics.TrueNegatives.Add(1)
                        return false, nil
                }</span>
        }

        <span class="cov3" title="19">bf.metrics.ContainsOperations.Add(1)
        // Note: We can't distinguish between true positives and false positives
        // without external verification, so we don't update false positive metrics here
        return true, nil</span>
}

// AddBatch adds multiple items to the Bloom filter with validation and improved context handling
func (bf *BloomFilter) AddBatch(ctx context.Context, items []string) error <span class="cov1" title="1">{
        // Check if filter is closed
        if atomic.LoadInt32(&amp;bf.closed) == 1 </span><span class="cov0" title="0">{
                return ErrFilterClosed
        }</span>

        // Validate input
        <span class="cov1" title="1">if err := validateBatch(items); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid batch: %w", err)
        }</span>

        // Check context cancellation before starting operation
        <span class="cov1" title="1">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %v", ErrContextCancelled, err)
        }</span>

        <span class="cov1" title="1">start := time.Now()
        defer func() </span><span class="cov1" title="1">{
                bf.updateAddBatchMetrics(time.Since(start), len(items))
        }</span>()

        // Use a timeout context to prevent indefinite blocking
        <span class="cov1" title="1">opCtx, cancel := context.WithTimeout(ctx, 60*time.Second) // Longer timeout for batch operations
        defer cancel()

        bf.mu.Lock()
        defer bf.mu.Unlock()

        // Check context cancellation after acquiring lock with timeout context
        if err := opCtx.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %v", ErrContextCancelled, err)
        }</span>

        <span class="cov1" title="1">addedCount := 0
        for i, item := range items </span><span class="cov2" title="5">{
                // Check context cancellation periodically during batch processing with timeout context
                if i%100 == 0 &amp;&amp; opCtx.Err() != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: %v", ErrContextCancelled, opCtx.Err())
                }</span>

                // Check capacity
                <span class="cov2" title="5">if bf.itemCount &gt;= bf.maxItems </span><span class="cov0" title="0">{
                        logx.Warn("Bloom filter at capacity during batch add",
                                logx.String("item_count", fmt.Sprintf("%d", bf.itemCount)),
                                logx.String("max_items", fmt.Sprintf("%d", bf.maxItems)),
                                logx.Int("items_processed", addedCount),
                                logx.Int("total_items", len(items)))
                        break</span>
                }

                // Get hash positions
                <span class="cov2" title="5">positions := bf.getHashPositions(item)

                // Set bits
                for _, pos := range positions </span><span class="cov4" title="35">{
                        bf.bitset[pos] = true
                }</span>

                <span class="cov2" title="5">bf.itemCount++
                addedCount++</span>
        }

        // Update metrics accurately for batch operations with atomic operations
        <span class="cov1" title="1">bf.metrics.AddBatchOperations.Add(1)
        bf.metrics.AddOperations.Add(uint64(addedCount)) // Count individual adds

        // Persist to store if available with dedicated store mutex
        if bf.store != nil &amp;&amp; addedCount &gt; 0 </span><span class="cov0" title="0">{
                if err := bf.saveToStoreWithRetry(opCtx); err != nil </span><span class="cov0" title="0">{
                        logx.Error("Failed to persist bloom filter state after batch add",
                                logx.ErrorField(err),
                                logx.Int("items_added", addedCount))
                        bf.metrics.StoreErrors.Add(1)
                        // Don't fail the operation if persistence fails
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// ContainsBatch checks if multiple items might be in the Bloom filter with improved context handling
func (bf *BloomFilter) ContainsBatch(ctx context.Context, items []string) (map[string]bool, error) <span class="cov0" title="0">{
        // Check if filter is closed
        if atomic.LoadInt32(&amp;bf.closed) == 1 </span><span class="cov0" title="0">{
                return nil, ErrFilterClosed
        }</span>

        // Validate input
        <span class="cov0" title="0">if err := validateBatch(items); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid batch: %w", err)
        }</span>

        // Check context cancellation before starting operation
        <span class="cov0" title="0">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %v", ErrContextCancelled, err)
        }</span>

        <span class="cov0" title="0">start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                bf.updateContainsBatchMetrics(time.Since(start), len(items))
        }</span>()

        // Use a timeout context to prevent indefinite blocking
        <span class="cov0" title="0">opCtx, cancel := context.WithTimeout(ctx, 60*time.Second) // Longer timeout for batch operations
        defer cancel()

        bf.mu.RLock()
        defer bf.mu.RUnlock()

        // Check context cancellation after acquiring lock with timeout context
        if err := opCtx.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %v", ErrContextCancelled, err)
        }</span>

        <span class="cov0" title="0">results := make(map[string]bool, len(items))

        for i, item := range items </span><span class="cov0" title="0">{
                // Check context cancellation periodically during batch processing with timeout context
                if i%100 == 0 &amp;&amp; opCtx.Err() != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: %v", ErrContextCancelled, opCtx.Err())
                }</span>

                // Get hash positions
                <span class="cov0" title="0">positions := bf.getHashPositions(item)

                // Check if all bits are set
                contains := true
                for _, pos := range positions </span><span class="cov0" title="0">{
                        if !bf.bitset[pos] </span><span class="cov0" title="0">{
                                contains = false
                                break</span>
                        }
                }

                <span class="cov0" title="0">results[item] = contains</span>
        }

        // Update metrics accurately for batch operations with atomic operations
        <span class="cov0" title="0">bf.metrics.ContainsBatchOperations.Add(1)
        bf.metrics.ContainsOperations.Add(uint64(len(items))) // Count individual contains

        return results, nil</span>
}

// Clear clears the Bloom filter
func (bf *BloomFilter) Clear(ctx context.Context) error <span class="cov1" title="1">{
        // Check if filter is closed
        if atomic.LoadInt32(&amp;bf.closed) == 1 </span><span class="cov0" title="0">{
                return errors.New("bloom filter is closed")
        }</span>

        // Check context cancellation
        <span class="cov1" title="1">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %v", ErrContextCancelled, err)
        }</span>

        <span class="cov1" title="1">bf.mu.Lock()
        defer bf.mu.Unlock()

        // Clear bitset
        for i := range bf.bitset </span><span class="cov7" title="959">{
                bf.bitset[i] = false
        }</span>

        <span class="cov1" title="1">bf.itemCount = 0

        // Clear from store if available
        if bf.store != nil </span><span class="cov0" title="0">{
                if err := bf.store.Del(ctx, bf.getStoreKey()); err != nil </span><span class="cov0" title="0">{
                        logx.Error("Failed to clear bloom filter from store", logx.ErrorField(err))
                        bf.metrics.StoreErrors.Add(1)
                        return fmt.Errorf("%w: %v", ErrStoreOperationFailed, err)
                }</span>
        }

        <span class="cov1" title="1">logx.Info("Bloom filter cleared successfully")
        return nil</span>
}

// GetStats returns comprehensive Bloom filter statistics with improved thread safety
func (bf *BloomFilter) GetStats() map[string]interface{} <span class="cov2" title="4">{
        bf.mu.RLock()
        defer bf.mu.RUnlock()

        // Calculate current false positive rate
        currentFPR := bf.calculateCurrentFalsePositiveRate()
        bitsSet := bf.countSetBits()

        stats := map[string]interface{}{
                "size":                        bf.size,
                "hash_count":                  bf.hashCount,
                "item_count":                  bf.itemCount,
                "max_items":                   bf.maxItems,
                "desired_false_positive_rate": bf.falsePositiveRate,
                "current_false_positive_rate": currentFPR,
                "load_factor":                 float64(bf.itemCount) / float64(bf.maxItems),
                "bits_set":                    bitsSet,
                "bits_set_percentage":         float64(bitsSet) / float64(bf.size) * 100,
                "is_at_capacity":              bf.itemCount &gt;= bf.maxItems,
                "available_capacity":          bf.maxItems - bf.itemCount,
        }

        // Add metrics with atomic operations for thread safety
        if bf.metrics != nil </span><span class="cov2" title="4">{
                stats["add_operations"] = bf.metrics.AddOperations.Load()
                stats["contains_operations"] = bf.metrics.ContainsOperations.Load()
                stats["add_batch_operations"] = bf.metrics.AddBatchOperations.Load()
                stats["contains_batch_operations"] = bf.metrics.ContainsBatchOperations.Load()
                stats["false_positives"] = bf.metrics.FalsePositives.Load()
                stats["true_negatives"] = bf.metrics.TrueNegatives.Load()
                stats["store_operations"] = bf.metrics.StoreOperations.Load()
                stats["store_errors"] = bf.metrics.StoreErrors.Load()

                // Use mutex only for complex metrics that can't be atomic
                bf.metrics.mu.RLock()
                defer bf.metrics.mu.RUnlock()
                stats["average_add_latency_ns"] = bf.metrics.AverageAddLatency.Nanoseconds()
                stats["average_contains_latency_ns"] = bf.metrics.AverageContainsLatency.Nanoseconds()
        }</span>

        <span class="cov2" title="4">return stats</span>
}

// Close closes the Bloom filter and releases resources
func (bf *BloomFilter) Close() error <span class="cov0" title="0">{
        if !atomic.CompareAndSwapInt32(&amp;bf.closed, 0, 1) </span><span class="cov0" title="0">{
                return errors.New("bloom filter already closed")
        }</span>

        <span class="cov0" title="0">logx.Info("Bloom filter closed successfully")
        return nil</span>
}

// IsClosed returns true if the Bloom filter is closed
func (bf *BloomFilter) IsClosed() bool <span class="cov0" title="0">{
        return atomic.LoadInt32(&amp;bf.closed) == 1
}</span>

// getHashPositions calculates hash positions for an item using multiple hash functions
func (bf *BloomFilter) getHashPositions(item string) []uint64 <span class="cov5" title="150">{
        positions := make([]uint64, bf.hashCount)

        // Use multiple hash functions for better distribution
        h1 := fnv.New64a()
        h1.Write([]byte(item))
        hash1 := h1.Sum64()

        h2 := md5.New()
        h2.Write([]byte(item))
        hash2 := binary.BigEndian.Uint64(h2.Sum(nil))

        h3 := sha256.New()
        h3.Write([]byte(item))
        hash3 := binary.BigEndian.Uint64(h3.Sum(nil))

        for i := 0; i &lt; bf.hashCount; i++ </span><span class="cov7" title="1050">{
                // Combine hashes using triple hashing for better distribution
                hash := hash1 + uint64(i)*hash2 + uint64(i*i)*hash3
                positions[i] = hash % bf.size
        }</span>

        <span class="cov5" title="150">return positions</span>
}

// countSetBits counts the number of set bits in the bitset efficiently
func (bf *BloomFilter) countSetBits() uint64 <span class="cov2" title="7">{
        count := uint64(0)
        for _, bit := range bf.bitset </span><span class="cov10" title="23967">{
                if bit </span><span class="cov7" title="1436">{
                        count++
                }</span>
        }
        <span class="cov2" title="7">return count</span>
}

// calculateCurrentFalsePositiveRate calculates the current false positive rate
func (bf *BloomFilter) calculateCurrentFalsePositiveRate() float64 <span class="cov2" title="4">{
        if bf.itemCount == 0 </span><span class="cov1" title="1">{
                return 0.0
        }</span>

        // Calculate probability of a bit being set
        <span class="cov1" title="3">p := float64(bf.countSetBits()) / float64(bf.size)

        // False positive rate = p^hashCount
        return math.Pow(p, float64(bf.hashCount))</span>
}

// getStoreKey returns the key for storing bloom filter state
func (bf *BloomFilter) getStoreKey() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:filter", bf.keyPrefix)
}</span>

// saveToStoreWithRetry saves the bloom filter state to the store with retry logic and store synchronization
func (bf *BloomFilter) saveToStoreWithRetry(ctx context.Context) error <span class="cov0" title="0">{
        if bf.store == nil </span><span class="cov0" title="0">{
                return ErrStoreUnavailable
        }</span>

        <span class="cov0" title="0">var lastErr error
        for attempt := 0; attempt &lt; MaxRetryAttempts; attempt++ </span><span class="cov0" title="0">{
                if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: %v", ErrContextCancelled, err)
                }</span>

                // Use dedicated store mutex to prevent concurrent store operations
                // but release it between retries to prevent deadlocks
                <span class="cov0" title="0">bf.storeMu.Lock()
                err := bf.saveToStore(ctx)
                bf.storeMu.Unlock()

                if err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                        if attempt &lt; MaxRetryAttempts-1 </span><span class="cov0" title="0">{
                                // Sleep outside of the mutex to prevent deadlocks
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return fmt.Errorf("%w: %v", ErrContextCancelled, ctx.Err())</span>
                                case &lt;-time.After(RetryDelay * time.Duration(attempt+1)):<span class="cov0" title="0">
                                        continue</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        bf.metrics.StoreOperations.Add(1)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("%w: %v", ErrStoreOperationFailed, lastErr)</span>
}

// saveToStore saves the bloom filter state to the store with enhanced serialization
func (bf *BloomFilter) saveToStore(ctx context.Context) error <span class="cov0" title="0">{
        // Check context cancellation before starting store operation
        if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %v", ErrContextCancelled, err)
        }</span>

        <span class="cov0" title="0">state := &amp;BloomFilterState{
                ItemCount: bf.itemCount,
                Size:      bf.size,
                HashCount: bf.hashCount,
                Bitset:    make([]bool, len(bf.bitset)),
                Version:   "1.1", // Enhanced version for production
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        // Copy bitset
        copy(state.Bitset, bf.bitset)

        // Enhanced serialization with compression and validation
        data, err := bf.serializeState(state)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %v", ErrSerializationFailed, err)
        }</span>

        // Check context cancellation before store operation
        <span class="cov0" title="0">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %v", ErrContextCancelled, err)
        }</span>

        <span class="cov0" title="0">return bf.store.Set(ctx, bf.getStoreKey(), data, bf.ttl)</span>
}

// serializeState provides enhanced serialization for production
func (bf *BloomFilter) serializeState(state *BloomFilterState) ([]byte, error) <span class="cov0" title="0">{
        // Create enhanced serialization structure
        enhancedState := map[string]interface{}{
                "version":    state.Version,
                "item_count": state.ItemCount,
                "size":       state.Size,
                "hash_count": state.HashCount,
                "created_at": state.CreatedAt.Format(time.RFC3339),
                "updated_at": state.UpdatedAt.Format(time.RFC3339),
                "metadata": map[string]interface{}{
                        "false_positive_rate": bf.falsePositiveRate,
                        "max_items":           bf.maxItems,
                        "key_prefix":          bf.keyPrefix,
                },
        }

        // Convert bitset to compact binary format for efficiency
        bitsetBytes := bf.bitsetToBytes(state.Bitset)
        enhancedState["bitset"] = bitsetBytes

        // Serialize to JSON with proper error handling
        data, err := json.Marshal(enhancedState)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal enhanced state: %w", err)
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// bitsetToBytes converts bitset to compact binary format
func (bf *BloomFilter) bitsetToBytes(bitset []bool) []byte <span class="cov0" title="0">{
        // Calculate required bytes (8 bits per byte)
        byteCount := (len(bitset) + 7) / 8
        bytes := make([]byte, byteCount)

        for i, bit := range bitset </span><span class="cov0" title="0">{
                if bit </span><span class="cov0" title="0">{
                        byteIndex := i / 8
                        bitIndex := i % 8
                        bytes[byteIndex] |= 1 &lt;&lt; bitIndex
                }</span>
        }

        <span class="cov0" title="0">return bytes</span>
}

// loadFromStoreWithRetry loads the bloom filter state from the store with retry logic and store synchronization
func (bf *BloomFilter) loadFromStoreWithRetry(ctx context.Context) error <span class="cov0" title="0">{
        if bf.store == nil </span><span class="cov0" title="0">{
                return ErrStoreUnavailable
        }</span>

        <span class="cov0" title="0">var lastErr error
        for attempt := 0; attempt &lt; MaxRetryAttempts; attempt++ </span><span class="cov0" title="0">{
                if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: %v", ErrContextCancelled, err)
                }</span>

                // Use dedicated store mutex to prevent concurrent store operations
                // but release it between retries to prevent deadlocks
                <span class="cov0" title="0">bf.storeMu.Lock()
                err := bf.loadFromStore(ctx)
                bf.storeMu.Unlock()

                if err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                        if attempt &lt; MaxRetryAttempts-1 </span><span class="cov0" title="0">{
                                // Sleep outside of the mutex to prevent deadlocks
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return fmt.Errorf("%w: %v", ErrContextCancelled, ctx.Err())</span>
                                case &lt;-time.After(RetryDelay * time.Duration(attempt+1)):<span class="cov0" title="0">
                                        continue</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        bf.metrics.StoreOperations.Add(1)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("%w: %v", ErrStoreOperationFailed, lastErr)</span>
}

// loadFromStore loads the bloom filter state from the store with enhanced deserialization
func (bf *BloomFilter) loadFromStore(ctx context.Context) error <span class="cov0" title="0">{
        // Check context cancellation before starting store operation
        if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %v", ErrContextCancelled, err)
        }</span>

        <span class="cov0" title="0">data, err := bf.store.Get(ctx, bf.getStoreKey())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check context cancellation after store operation
        <span class="cov0" title="0">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %v", ErrContextCancelled, err)
        }</span>

        <span class="cov0" title="0">state, err := bf.deserializeState(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %v", ErrDeserializationFailed, err)
        }</span>

        // Validate loaded state
        <span class="cov0" title="0">if err := validateBloomFilterState(state, bf.size, bf.hashCount); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid loaded state: %w", err)
        }</span>

        // Apply loaded state
        <span class="cov0" title="0">bf.mu.Lock()
        defer bf.mu.Unlock()

        bf.itemCount = state.ItemCount
        copy(bf.bitset, state.Bitset)

        logx.Info("Bloom filter state loaded from store",
                logx.String("item_count", fmt.Sprintf("%d", state.ItemCount)),
                logx.String("version", state.Version),
                logx.String("updated_at", state.UpdatedAt.Format(time.RFC3339)))

        return nil</span>
}

// deserializeState provides enhanced deserialization for production
func (bf *BloomFilter) deserializeState(data []byte) (*BloomFilterState, error) <span class="cov0" title="0">{
        // Try enhanced format first
        var enhancedState map[string]interface{}
        if err := json.Unmarshal(data, &amp;enhancedState); err != nil </span><span class="cov0" title="0">{
                // Fallback to legacy format
                return bf.deserializeLegacyState(data)
        }</span>

        // Extract version and validate
        <span class="cov0" title="0">version, ok := enhancedState["version"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("invalid version in enhanced state")
        }</span>

        // Extract basic fields
        <span class="cov0" title="0">itemCount, ok := enhancedState["item_count"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("invalid item_count in enhanced state")
        }</span>

        <span class="cov0" title="0">size, ok := enhancedState["size"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("invalid size in enhanced state")
        }</span>

        <span class="cov0" title="0">hashCount, ok := enhancedState["hash_count"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("invalid hash_count in enhanced state")
        }</span>

        // Extract bitset
        <span class="cov0" title="0">bitsetBytes, ok := enhancedState["bitset"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("invalid bitset in enhanced state")
        }</span>

        // Convert bitset bytes back to bool slice
        <span class="cov0" title="0">bitset := bf.bytesToBitset(bitsetBytes, int(size))

        // Parse timestamps
        createdAtStr, ok := enhancedState["created_at"].(string)
        if !ok </span><span class="cov0" title="0">{
                createdAtStr = time.Now().Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">updatedAtStr, ok := enhancedState["updated_at"].(string)
        if !ok </span><span class="cov0" title="0">{
                updatedAtStr = time.Now().Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">createdAt, _ := time.Parse(time.RFC3339, createdAtStr)
        updatedAt, _ := time.Parse(time.RFC3339, updatedAtStr)

        state := &amp;BloomFilterState{
                ItemCount: uint64(itemCount),
                Size:      uint64(size),
                HashCount: int(hashCount),
                Bitset:    bitset,
                Version:   version,
                CreatedAt: createdAt,
                UpdatedAt: updatedAt,
        }

        return state, nil</span>
}

// deserializeLegacyState handles legacy serialization format
func (bf *BloomFilter) deserializeLegacyState(data []byte) (*BloomFilterState, error) <span class="cov0" title="0">{
        var state BloomFilterState
        if err := json.Unmarshal(data, &amp;state); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal legacy state: %w", err)
        }</span>

        // Set default values for missing fields
        <span class="cov0" title="0">if state.Version == "" </span><span class="cov0" title="0">{
                state.Version = "1.0"
        }</span>
        <span class="cov0" title="0">if state.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                state.CreatedAt = time.Now()
        }</span>
        <span class="cov0" title="0">if state.UpdatedAt.IsZero() </span><span class="cov0" title="0">{
                state.UpdatedAt = time.Now()
        }</span>

        <span class="cov0" title="0">return &amp;state, nil</span>
}

// bytesToBitset converts compact binary format back to bool slice
func (bf *BloomFilter) bytesToBitset(bytes []interface{}, size int) []bool <span class="cov0" title="0">{
        bitset := make([]bool, size)

        for i := 0; i &lt; size; i++ </span><span class="cov0" title="0">{
                byteIndex := i / 8
                bitIndex := i % 8

                if byteIndex &lt; len(bytes) </span><span class="cov0" title="0">{
                        if byteVal, ok := bytes[byteIndex].(float64); ok </span><span class="cov0" title="0">{
                                bitset[i] = (uint8(byteVal) &amp; (1 &lt;&lt; bitIndex)) != 0
                        }</span>
                }
        }

        <span class="cov0" title="0">return bitset</span>
}

// updateAddMetrics updates add operation metrics with improved thread safety
func (bf *BloomFilter) updateAddMetrics(duration time.Duration) <span class="cov5" title="120">{
        if bf.metrics == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Use mutex only for complex metrics that can't be atomic
        <span class="cov5" title="120">bf.metrics.mu.Lock()
        defer bf.metrics.mu.Unlock()

        bf.metrics.LastAddTime = time.Now()
        if bf.metrics.AverageAddLatency == 0 </span><span class="cov2" title="6">{
                bf.metrics.AverageAddLatency = duration
        }</span> else<span class="cov5" title="114"> {
                bf.metrics.AverageAddLatency = (bf.metrics.AverageAddLatency + duration) / 2
        }</span>
}

// updateContainsMetrics updates contains operation metrics with improved thread safety
func (bf *BloomFilter) updateContainsMetrics(duration time.Duration) <span class="cov3" title="25">{
        if bf.metrics == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Use mutex only for complex metrics that can't be atomic
        <span class="cov3" title="25">bf.metrics.mu.Lock()
        defer bf.metrics.mu.Unlock()

        bf.metrics.LastContainsTime = time.Now()
        if bf.metrics.AverageContainsLatency == 0 </span><span class="cov2" title="4">{
                bf.metrics.AverageContainsLatency = duration
        }</span> else<span class="cov3" title="21"> {
                bf.metrics.AverageContainsLatency = (bf.metrics.AverageContainsLatency + duration) / 2
        }</span>
}

// updateAddBatchMetrics updates batch add operation metrics with accurate counting and improved thread safety
func (bf *BloomFilter) updateAddBatchMetrics(duration time.Duration, itemCount int) <span class="cov1" title="1">{
        if bf.metrics == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Use mutex only for complex metrics that can't be atomic
        <span class="cov1" title="1">bf.metrics.mu.Lock()
        defer bf.metrics.mu.Unlock()

        bf.metrics.LastAddTime = time.Now()

        // Calculate average latency per item for batch operations
        if itemCount &gt; 0 </span><span class="cov1" title="1">{
                avgPerItem := duration / time.Duration(itemCount)
                if bf.metrics.AverageAddLatency == 0 </span><span class="cov1" title="1">{
                        bf.metrics.AverageAddLatency = avgPerItem
                }</span> else<span class="cov0" title="0"> {
                        // Weighted average to account for batch operations
                        bf.metrics.AverageAddLatency = (bf.metrics.AverageAddLatency + avgPerItem) / 2
                }</span>
        }
}

// updateContainsBatchMetrics updates batch contains operation metrics with accurate counting and improved thread safety
func (bf *BloomFilter) updateContainsBatchMetrics(duration time.Duration, itemCount int) <span class="cov0" title="0">{
        if bf.metrics == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Use mutex only for complex metrics that can't be atomic
        <span class="cov0" title="0">bf.metrics.mu.Lock()
        defer bf.metrics.mu.Unlock()

        bf.metrics.LastContainsTime = time.Now()

        // Calculate average latency per item for batch operations
        if itemCount &gt; 0 </span><span class="cov0" title="0">{
                avgPerItem := duration / time.Duration(itemCount)
                if bf.metrics.AverageContainsLatency == 0 </span><span class="cov0" title="0">{
                        bf.metrics.AverageContainsLatency = avgPerItem
                }</span> else<span class="cov0" title="0"> {
                        // Weighted average to account for batch operations
                        bf.metrics.AverageContainsLatency = (bf.metrics.AverageContainsLatency + avgPerItem) / 2
                }</span>
        }
}

// validateConfig validates Bloom filter configuration
func validateConfig(config *Config) error <span class="cov3" title="12">{
        if config == nil </span><span class="cov0" title="0">{
                return errors.New("config cannot be nil")
        }</span>

        <span class="cov3" title="12">if config.ExpectedItems &lt; MinExpectedItems || config.ExpectedItems &gt; MaxExpectedItems </span><span class="cov1" title="1">{
                return fmt.Errorf("%w: expected items must be between %d and %d, got %d",
                        ErrInvalidExpectedItems, MinExpectedItems, MaxExpectedItems, config.ExpectedItems)
        }</span>

        <span class="cov3" title="11">if config.FalsePositiveRate &lt; MinFalsePositive || config.FalsePositiveRate &gt; MaxFalsePositive </span><span class="cov1" title="2">{
                return fmt.Errorf("%w: false positive rate must be between %f and %f, got %f",
                        ErrInvalidFalsePositive, MinFalsePositive, MaxFalsePositive, config.FalsePositiveRate)
        }</span>

        <span class="cov2" title="9">return nil</span>
}

// validateItem validates a single item
func validateItem(item string) error <span class="cov5" title="152">{
        if item == "" </span><span class="cov1" title="2">{
                return ErrEmptyItem
        }</span>

        <span class="cov5" title="150">if len(item) &gt; MaxItemLength </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: item length %d exceeds maximum %d",
                        ErrItemTooLong, len(item), MaxItemLength)
        }</span>

        <span class="cov5" title="150">return nil</span>
}

// validateBatch validates a slice of items
func validateBatch(items []string) error <span class="cov1" title="1">{
        if len(items) == 0 </span><span class="cov0" title="0">{
                return errors.New("items slice cannot be empty")
        }</span>

        <span class="cov1" title="1">for i, item := range items </span><span class="cov2" title="5">{
                if err := validateItem(item); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid item at index %d: %w", i, err)
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// validateBloomFilterState validates the loaded Bloom filter state
func validateBloomFilterState(state *BloomFilterState, expectedSize uint64, expectedHashCount int) error <span class="cov0" title="0">{
        if state == nil </span><span class="cov0" title="0">{
                return errors.New("state cannot be nil")
        }</span>

        <span class="cov0" title="0">if state.Size != expectedSize </span><span class="cov0" title="0">{
                return fmt.Errorf("loaded size %d does not match expected %d", state.Size, expectedSize)
        }</span>

        <span class="cov0" title="0">if state.HashCount != expectedHashCount </span><span class="cov0" title="0">{
                return fmt.Errorf("loaded hash count %d does not match expected %d", state.HashCount, expectedHashCount)
        }</span>

        <span class="cov0" title="0">if len(state.Bitset) != int(expectedSize) </span><span class="cov0" title="0">{
                return fmt.Errorf("loaded bitset length %d does not match expected size %d", len(state.Bitset), expectedSize)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// applyDefaults applies default values to configuration
func applyDefaults(config *Config) <span class="cov2" title="9">{
        if config.KeyPrefix == "" </span><span class="cov2" title="9">{
                config.KeyPrefix = DefaultKeyPrefix
        }</span>

        <span class="cov2" title="9">if config.TTL == 0 </span><span class="cov2" title="9">{
                config.TTL = DefaultTTL
        }</span>
}

// calculateOptimalParameters calculates optimal size and hash count with validation
func calculateOptimalParameters(n uint64, p float64) (size uint64, hashCount int, err error) <span class="cov2" title="9">{
        // Calculate optimal size
        size = calculateOptimalSize(n, p)
        if size == 0 || size &gt; MaxBitsetSize </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("%w: calculated size %d is invalid", ErrInvalidSize, size)
        }</span>

        // Calculate optimal hash count
        <span class="cov2" title="9">hashCount = calculateOptimalHashCount(size, n)
        if hashCount &lt; MinHashCount || hashCount &gt; MaxHashCount </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("%w: calculated hash count %d is invalid", ErrInvalidHashCount, hashCount)
        }</span>

        <span class="cov2" title="9">return size, hashCount, nil</span>
}

// calculateOptimalSize calculates the optimal size for the bitset
func calculateOptimalSize(n uint64, p float64) uint64 <span class="cov2" title="9">{
        m := float64(n) * math.Log(p) / (math.Log(2) * math.Log(2))
        return uint64(math.Ceil(-m))
}</span>

// calculateOptimalHashCount calculates the optimal number of hash functions
func calculateOptimalHashCount(m, n uint64) int <span class="cov2" title="9">{
        k := float64(m) / float64(n) * math.Log(2)
        return int(math.Ceil(k))
}</span>

// truncateString truncates a string for logging purposes
func truncateString(s string, maxLen int) string <span class="cov0" title="0">{
        if len(s) &lt;= maxLen </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:maxLen] + "..."</span>
}

// DefaultConfig returns a default Bloom filter configuration
func DefaultConfig(store BloomStore) *Config <span class="cov0" title="0">{
        return &amp;Config{
                ExpectedItems:     10000,
                FalsePositiveRate: 0.01, // 1%
                Store:             store,
                KeyPrefix:         DefaultKeyPrefix,
                TTL:               DefaultTTL,
                EnableMetrics:     true,
        }
}</span>

// ConservativeConfig returns a conservative Bloom filter configuration
func ConservativeConfig(store BloomStore) *Config <span class="cov0" title="0">{
        return &amp;Config{
                ExpectedItems:     50000,
                FalsePositiveRate: 0.001, // 0.1%
                Store:             store,
                KeyPrefix:         DefaultKeyPrefix,
                TTL:               DefaultTTL,
                EnableMetrics:     true,
        }
}</span>

// AggressiveConfig returns an aggressive Bloom filter configuration
func AggressiveConfig(store BloomStore) *Config <span class="cov0" title="0">{
        return &amp;Config{
                ExpectedItems:     1000,
                FalsePositiveRate: 0.05, // 5%
                Store:             store,
                KeyPrefix:         DefaultKeyPrefix,
                TTL:               DefaultTTL,
                EnableMetrics:     true,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
